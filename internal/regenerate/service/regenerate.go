package service

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/alfariiizi/vandor-cli/internal/utils"
)

func RegenerateService() error {
	if err := regenerateServicesGo(); err != nil {
		return fmt.Errorf("failed to regenerate services.go: %w", err)
	}
	if err := regenerateGroupServiceGo(); err != nil {
		return fmt.Errorf("failed to regenerate group service.go: %w", err)
	}
	fmt.Printf("âœ… Successfully regenerated service\n")
	return nil
}

func regenerateServicesGo() error {
	serviceRoot := "internal/core/service"
	groupStructMap := map[string]string{}

	dirs, err := os.ReadDir(serviceRoot)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		group := dir.Name()
		serviceFile := filepath.Join(serviceRoot, group, "service.go")

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, serviceFile, nil, 0)
		if err != nil {
			continue
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				typeSpec := spec.(*ast.TypeSpec)
				if typeSpec.Name.IsExported() && strings.HasSuffix(typeSpec.Name.Name, "Service") {
					groupStructMap[group] = typeSpec.Name.Name
				}
			}
		}
	}

	// Generate services.go
	var buf bytes.Buffer
	buf.WriteString("// Package service provides all services for the application.\n")
	buf.WriteString("// Code generated by Service Generator. DO NOT EDIT.\n")
	buf.WriteString("// Template: https://github.com/alfariiizi/vandor-cli.\n")
	buf.WriteString("package service\n\n")
	buf.WriteString("import (\n\t\"go.uber.org/fx\"\n")
	moduleName := utils.GetModuleName()
	for group := range groupStructMap {
		buf.WriteString(fmt.Sprintf("\t%s_service \"%s/internal/core/service/%s\"\n", group, moduleName, group))
	}
	buf.WriteString(")\n\n")

	buf.WriteString("type Services struct {\n")
	for group, structName := range groupStructMap {
		buf.WriteString(fmt.Sprintf("\t%s %s_service.%s\n", utils.ToTitle(group), group, structName))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("func NewServices(\n")
	for group, structName := range groupStructMap {
		param := strings.ToLower(group)
		buf.WriteString(fmt.Sprintf("\t%s %s_service.%s,\n", param, group, structName))
	}
	buf.WriteString(") *Services {\n\treturn &Services{\n")
	for group := range groupStructMap {
		buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", utils.ToTitle(group), strings.ToLower(group)))
	}
	buf.WriteString("\t}\n}\n\n")

	buf.WriteString("var Module = fx.Module(\n\t\"service\",\n\tfx.Provide(\n\t\tNewServices,\n\t),\n")
	for group := range groupStructMap {
		buf.WriteString(fmt.Sprintf("\t%s_service.Module,\n", group))
	}
	buf.WriteString(")\n")

	return os.WriteFile(filepath.Join(serviceRoot, "services.go"), buf.Bytes(), 0644)
}

func regenerateGroupServiceGo() error {
	serviceRoot := "internal/core/service"
	groupServiceMap := map[string][]string{}

	// 1. Walk all group dirs and collect services
	dirs, err := os.ReadDir(serviceRoot)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		group := dir.Name()
		groupDir := filepath.Join(serviceRoot, group)

		err := filepath.WalkDir(groupDir, func(path string, d os.DirEntry, err error) error {
			if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") || d.Name() == "service.go" {
				return nil
			}

			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, path, nil, 0)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					if typeSpec.Name.IsExported() {
						switch typeSpec.Type.(type) {
						case *ast.IndexExpr, *ast.IndexListExpr:
							groupServiceMap[group] = append(groupServiceMap[group], typeSpec.Name.Name)
						}
					}
				}
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// 2. Generate `service.go` for each group
	for group, services := range groupServiceMap {
		structName := utils.ToTitle(group) + "Service"
		var buf bytes.Buffer
		buf.WriteString(fmt.Sprintf("// Package %s_service provides services for the %s group.\n", group, group))
		buf.WriteString("// Code generated by Service Generator. DO NOT EDIT.\n")
		buf.WriteString("// Template: https://github.com/alfariiizi/vandor-cli.\n")
		buf.WriteString(fmt.Sprintf("package %s_service\n\n", group))
		buf.WriteString("import \"go.uber.org/fx\"\n\n")
		buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		for _, s := range services {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", s, s))
		}
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("func New%s(\n", structName))
		for _, s := range services {
			param := strings.ToLower(s[:1]) + s[1:]
			buf.WriteString(fmt.Sprintf("\t%s %s,\n", param, s))
		}
		buf.WriteString(fmt.Sprintf(") %s {\n", structName))
		buf.WriteString(fmt.Sprintf("\treturn %s{\n", structName))
		for _, s := range services {
			param := strings.ToLower(s[:1]) + s[1:]
			buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", s, param))
		}
		buf.WriteString("\t}\n}\n\n")

		// fx.Module
		buf.WriteString(fmt.Sprintf("var Module = fx.Module(\n\t\"%s_service\",\n\tfx.Provide(\n", group))
		for _, s := range services {
			buf.WriteString(fmt.Sprintf("\t\tNew%s,\n", s))
		}
		buf.WriteString(fmt.Sprintf("\t\tNew%s,\n", structName))
		buf.WriteString("\t),\n)\n")

		err := os.WriteFile(filepath.Join(serviceRoot, group, "service.go"), buf.Bytes(), 0644)
		if err != nil {
			return fmt.Errorf("failed to write %s/service.go: %w", group, err)
		}
	}

	return nil
}
