package usecase

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func RegenerateUsecase() error {
	usecaseDir := "internal/core/usecase"
	files, err := os.ReadDir(usecaseDir)
	if err != nil {
		return err
	}

	usecases := []string{}

	for _, file := range files {
		if file.IsDir() || file.Name() == "usecases.go" || !strings.HasSuffix(file.Name(), ".go") {
			continue
		}

		path := filepath.Join(usecaseDir, file.Name())
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %w", path, err)
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				typeSpec := spec.(*ast.TypeSpec)
				if !typeSpec.Name.IsExported() {
					continue
				}
				// Filter only aliases to model.Usecase[...] (not structs like LoginInput)
				switch typeSpec.Type.(type) {
				case *ast.IndexExpr, *ast.IndexListExpr:
					usecases = append(usecases, typeSpec.Name.Name)
				}
			}
		}
	}

	var buf bytes.Buffer
	buf.WriteString("// Package usecase provide usecases for the application.\n")
	buf.WriteString("// Code generated by Usecase Generator. DO NOT EDIT.\n")
	buf.WriteString("// Template: https://github.com/alfariiizi/vandor-cli.\n")
	buf.WriteString("package usecase\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"go.uber.org/fx\"\n")
	buf.WriteString(")\n\n")

	// struct
	buf.WriteString("type Usecases struct {\n")
	for _, name := range usecases {
		buf.WriteString(fmt.Sprintf("\t%s %s\n", name, name))
	}
	buf.WriteString("}\n\n")

	// constructor
	buf.WriteString("func NewUsecases(\n")
	for _, name := range usecases {
		param := strings.ToLower(name[:1]) + name[1:]
		buf.WriteString(fmt.Sprintf("\t%s %s,\n", param, name))
	}
	buf.WriteString(") *Usecases {\n")
	buf.WriteString("\treturn &Usecases{\n")
	for _, name := range usecases {
		param := strings.ToLower(name[:1]) + name[1:]
		buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", name, param))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// fx module
	buf.WriteString("var Module = fx.Module(\n")
	buf.WriteString("\t\"usecase\",\n")
	buf.WriteString("\tfx.Provide(\n")
	for _, name := range usecases {
		buf.WriteString(fmt.Sprintf("\t\tNew%s,\n", name))
	}
	buf.WriteString("\t\tNewUsecases,\n")
	buf.WriteString("\t),\n")
	buf.WriteString(")\n")

	fmt.Printf("âœ… Successfully regenerated usecase\n")
	return os.WriteFile(filepath.Join(usecaseDir, "usecases.go"), buf.Bytes(), 0644)
}
