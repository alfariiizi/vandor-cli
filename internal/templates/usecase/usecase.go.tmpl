package usecase

import (
	"context"

	domain_entries "{{.ModuleName}}/internal/core/domain"
	"{{.ModuleName}}/internal/core/model"
	"{{.ModuleName}}/internal/infrastructure/db"
	"{{.ModuleName}}/internal/pkg/validator"
	"{{.ModuleName}}/internal/infrastructure/sse"
	"{{.ModuleName}}/internal/pkg/logger"
)

// {{.Name}}Input defines the input for {{.Name}} usecase
type {{.Name}}Input struct {
	// TODO: Define input fields
}

// {{.Name}}Output defines the output for {{.Name}} usecase
type {{.Name}}Output struct {
	// TODO: Define output fields
}

// {{.Name}} defines the interface for {{.Name}} usecase
type {{.Name}} model.Usecase[{{.Name}}Input, {{.Name}}Output]

// {{.Receiver}} implements the {{.Name}} usecase
type {{.Receiver}} struct {
	client    *db.Client
	domain    *domain_entries.Domain
	validator validator.Validator
	sse       *sse.Manager
}

// New{{.Name}} creates a new instance of {{.Name}} usecase
func New{{.Name}}(
	client *db.Client,
	domain *domain_entries.Domain,
	validator validator.Validator,
	sse *sse.Manager,
) {{.Name}} {
	return &{{.Receiver}}{
		client:    client,
		domain:    domain,
		validator: validator,
		sse:       sse,
	}
}

// Validate validates the input for {{.Name}} usecase
func (uc *{{.Receiver}}) Validate(input {{.Name}}Input) error {
	return uc.validator.Validate(input)
}

// Execute executes the {{.Name}} usecase
func (uc *{{.Receiver}}) Execute(ctx context.Context, input {{.Name}}Input) (*{{.Name}}Output, error) {
	log := logger.Get()

	if err := uc.Validate(input); err != nil {
		log.Error().
			Str("usecase", "{{.Name}}").
			Err(err).
			Msg("Validation failed for {{.Name}}")
		return nil, err
	}

	res, err := uc.Process(ctx, input)
	if err != nil {
		log.Error().
			Str("usecase", "{{.Name}}").
			Err(err).
			Msg("Failed to process {{.Name}}")
		return nil, err
	}

	// Send event after successful processing (optional)
	if err := uc.SendEvent(ctx, input, *res); err != nil {
		log.Error().
			Str("usecase", "{{.Name}}").
			Err(err).
			Msg("Failed to send event for {{.Name}}")
		// Don't return error here, as the main operation succeeded
	}

	// Run observer logic (optional)
	if err := uc.Observer(ctx, input); err != nil {
		log.Error().
			Str("usecase", "{{.Name}}").
			Err(err).
			Msg("Observer failed for {{.Name}}")
		// Don't return error here, as the main operation succeeded
	}

	return res, nil
}

// Process contains the main business logic for {{.Name}} usecase
func (uc *{{.Receiver}}) Process(ctx context.Context, input {{.Name}}Input) (*{{.Name}}Output, error) {
	// TODO: Implement your business logic here

	return &{{.Name}}Output{
		// TODO: Set output fields
	}, nil
}

// Observer handles side effects after successful processing (optional)
func (uc *{{.Receiver}}) Observer(ctx context.Context, input {{.Name}}Input) error {
	// TODO: Implement observer logic (e.g., logging, metrics, notifications)
	// This is optional and should not affect the main business flow
	return nil
}

// SendEvent sends domain events after successful processing (optional)
func (uc *{{.Receiver}}) SendEvent(ctx context.Context, input {{.Name}}Input, output {{.Name}}Output) error {
	// TODO: Implement event sending logic (e.g., publish to message queue, SSE)
	// This is optional and should not affect the main business flow
	return nil
}