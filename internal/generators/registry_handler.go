package generators

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/vandordev/vandor/internal/utils"
)

func GenerateHandlerRegistry() error {
	routeDir := "internal/delivery/http/route"
	moduleName := utils.GetModuleName()

	// Discover handlers by groups
	handlerGroups, err := discoverHandlerGroups(routeDir)
	if err != nil {
		return fmt.Errorf("error discovering handler groups: %w", err)
	}

	if len(handlerGroups) == 0 {
		fmt.Println("No handler groups found in", routeDir)
		return nil
	}

	// Generate routes.go
	routesPath := filepath.Join(routeDir, "routes.go")
	if err := generateRoutesFile(handlerGroups, routesPath, moduleName); err != nil {
		return fmt.Errorf("error generating routes file: %w", err)
	}

	fmt.Printf("Handler registry generated successfully at %s\n", routesPath)
	fmt.Printf("Registered %d handler groups:\n", len(handlerGroups))
	for group, handlers := range handlerGroups {
		fmt.Printf("  - %s: %d handlers\n", group, len(handlers))
	}

	return nil
}

func discoverHandlerGroups(routeDir string) (map[string][]string, error) {
	handlerGroups := map[string][]string{}

	entries, err := os.ReadDir(routeDir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		group := entry.Name()
		groupDir := filepath.Join(routeDir, group)

		files, err := os.ReadDir(groupDir)
		if err != nil {
			continue
		}

		var handlers []string
		for _, file := range files {
			if strings.HasSuffix(file.Name(), ".go") && file.Name() != "service.go" {
				fset := token.NewFileSet()
				astFile, err := parser.ParseFile(fset, filepath.Join(groupDir, file.Name()), nil, parser.AllErrors)
				if err != nil {
					continue
				}

				for _, decl := range astFile.Decls {
					fn, ok := decl.(*ast.FuncDecl)
					if ok && fn.Recv == nil && fn.Name.IsExported() && strings.HasPrefix(fn.Name.Name, "New") {
						handlers = append(handlers, fn.Name.Name)
					}
				}
			}
		}

		if len(handlers) > 0 {
			// Sort handlers for consistent output
			sort.Strings(handlers)
			handlerGroups[group] = handlers
		}
	}

	return handlerGroups, nil
}

func generateRoutesFile(handlerGroups map[string][]string, outputPath, moduleName string) error {
	f := jen.NewFile("route")

	// Add header comment
	f.Comment("Package route provides HTTP routes for the application.")
	f.Comment("Code generated by HTTP Handler Generator. DO NOT EDIT.")
	f.Comment("Template: https://github.com/vandordev/vandor.")

	// Sort groups for consistent output
	var sortedGroups []string
	for group := range handlerGroups {
		sortedGroups = append(sortedGroups, group)
	}
	sort.Strings(sortedGroups)

	// Add imports
	for _, group := range sortedGroups {
		importAlias := group + "_handler"
		f.ImportAlias(moduleName+"/internal/delivery/http/route/"+group, importAlias)
	}
	f.ImportName("go.uber.org/fx", "fx")

	// Generate fx.Module with all handler invocations
	var invocations []jen.Code
	for _, group := range sortedGroups {
		importAlias := group + "_handler"
		for _, handler := range handlerGroups[group] {
			invocations = append(invocations, jen.Qual(importAlias, handler))
		}
	}

	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit("route"),
		jen.Qual("fx", "Invoke").Call(invocations...),
	)

	// Ensure directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save routes file: %w", err)
	}

	return nil
}