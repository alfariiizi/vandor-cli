package generators

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/alfariiizi/vandor-cli/internal/utils"
)

func GenerateServiceRegistry() error {
	serviceRoot := "internal/core/service"

	// Generate group service files first
	if err := generateGroupServiceFiles(serviceRoot); err != nil {
		return fmt.Errorf("error generating group service files: %w", err)
	}

	// Then generate main services.go
	if err := generateMainServiceRegistry(serviceRoot); err != nil {
		return fmt.Errorf("error generating main service registry: %w", err)
	}

	return nil
}

func generateGroupServiceFiles(serviceRoot string) error {
	groupServiceMap := map[string][]string{}

	// 1. Walk all group dirs and collect services
	dirs, err := os.ReadDir(serviceRoot)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		group := dir.Name()
		groupDir := filepath.Join(serviceRoot, group)

		err := filepath.WalkDir(groupDir, func(path string, d os.DirEntry, err error) error {
			if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") || d.Name() == "service.go" {
				return nil
			}

			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, path, nil, 0)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE {
					continue
				}
				for _, spec := range gen.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					if typeSpec.Name.IsExported() {
						switch typeSpec.Type.(type) {
						case *ast.IndexExpr, *ast.IndexListExpr:
							groupServiceMap[group] = append(groupServiceMap[group], typeSpec.Name.Name)
						}
					}
				}
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// 2. Generate `service.go` for each group
	for group, services := range groupServiceMap {
		if err := generateGroupServiceFile(serviceRoot, group, services); err != nil {
			return fmt.Errorf("error generating group service file for %s: %w", group, err)
		}
		fmt.Printf("Generated group service file for %s with %d services\n", group, len(services))
	}

	return nil
}

func generateGroupServiceFile(serviceRoot, group string, services []string) error {
	// Sort services for consistent output
	sort.Strings(services)

	structName := utils.ToPascalCase(group) + "Service"
	f := jen.NewFile(group + "_service")

	// Add header comment
	f.Comment(fmt.Sprintf("Package %s_service provides services for the %s group.", group, group))
	f.Comment("Code generated by Service Generator. DO NOT EDIT.")
	f.Comment("Template: https://github.com/alfariiizi/vandor-cli.")

	// Add imports
	f.ImportName("go.uber.org/fx", "fx")

	// Generate group service struct
	serviceFields := []jen.Code{}
	for _, service := range services {
		serviceFields = append(serviceFields, jen.Id(service).Id(service))
	}
	f.Type().Id(structName).Struct(serviceFields...)

	// Generate constructor parameters
	constructorParams := []jen.Code{}
	constructorDict := jen.Dict{}

	for _, service := range services {
		param := strings.ToLower(service[:1]) + service[1:]
		constructorParams = append(constructorParams, jen.Id(param).Id(service))
		constructorDict[jen.Id(service)] = jen.Id(param)
	}

	// Generate constructor
	f.Func().Id("New" + structName).Params(constructorParams...).Id(structName).Block(
		jen.Return(jen.Id(structName).Values(constructorDict)),
	)

	// Generate fx.Module with providers
	moduleProviders := []jen.Code{}
	for _, service := range services {
		moduleProviders = append(moduleProviders, jen.Id("New"+service))
	}
	moduleProviders = append(moduleProviders, jen.Id("New"+structName))

	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit(group+"_service"),
		jen.Qual("fx", "Provide").Call(moduleProviders...),
	)

	// Write file
	outputPath := filepath.Join(serviceRoot, group, "service.go")
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save group service file: %w", err)
	}

	return nil
}

func generateMainServiceRegistry(serviceRoot string) error {
	groupStructMap := map[string]string{}

	dirs, err := os.ReadDir(serviceRoot)
	if err != nil {
		return err
	}

	for _, dir := range dirs {
		if !dir.IsDir() {
			continue
		}
		group := dir.Name()
		serviceFile := filepath.Join(serviceRoot, group, "service.go")

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, serviceFile, nil, 0)
		if err != nil {
			continue
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				typeSpec := spec.(*ast.TypeSpec)
				if typeSpec.Name.IsExported() && strings.HasSuffix(typeSpec.Name.Name, "Service") {
					groupStructMap[group] = typeSpec.Name.Name
				}
			}
		}
	}

	// Generate main services.go
	moduleName := utils.GetModuleName()
	f := jen.NewFile("service")

	// Add header comment
	f.Comment("Package service provides all services for the application.")
	f.Comment("Code generated by Service Generator. DO NOT EDIT.")
	f.Comment("Template: https://github.com/alfariiizi/vandor-cli.")

	// Add imports
	f.ImportName("go.uber.org/fx", "fx")

	// Sort groups for consistent output
	var sortedGroups []string
	for group := range groupStructMap {
		sortedGroups = append(sortedGroups, group)
	}
	sort.Strings(sortedGroups)

	// Add group imports
	for _, group := range sortedGroups {
		f.ImportAlias(moduleName+"/internal/core/service/"+group, group+"_service")
	}

	// Generate Services struct
	serviceFields := []jen.Code{}
	for _, group := range sortedGroups {
		structName := groupStructMap[group]
		serviceFields = append(serviceFields,
			jen.Id(utils.ToPascalCase(group)).Qual(group+"_service", structName),
		)
	}
	f.Type().Id("Services").Struct(serviceFields...)

	// Generate constructor parameters
	constructorParams := []jen.Code{}
	constructorDict := jen.Dict{}

	for _, group := range sortedGroups {
		structName := groupStructMap[group]
		param := strings.ToLower(group)
		constructorParams = append(constructorParams,
			jen.Id(param).Qual(group+"_service", structName),
		)
		constructorDict[jen.Id(utils.ToPascalCase(group))] = jen.Id(param)
	}

	// Generate NewServices constructor
	f.Func().Id("NewServices").Params(constructorParams...).Op("*").Id("Services").Block(
		jen.Return(jen.Op("&").Id("Services").Values(constructorDict)),
	)

	// Generate fx.Module with group modules
	moduleProviders := []jen.Code{jen.Id("NewServices")}
	for _, group := range sortedGroups {
		moduleProviders = append(moduleProviders, jen.Qual(group+"_service", "Module"))
	}

	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit("service"),
		jen.Qual("fx", "Provide").Call(jen.Id("NewServices")),
		jen.Qual("fx", "Options").Call(moduleProviders[1:]...),
	)

	// Write file
	outputPath := filepath.Join(serviceRoot, "services.go")
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save main service registry: %w", err)
	}

	fmt.Printf("Service registry generated successfully at %s\n", outputPath)
	fmt.Printf("Registered %d service groups:\n", len(sortedGroups))
	for _, group := range sortedGroups {
		fmt.Printf("  - %s (%s)\n", group, groupStructMap[group])
	}

	return nil
}
