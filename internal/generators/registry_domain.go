package generators

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/alfariiizi/vandor-cli/internal/utils"
)

type DomainInfo struct {
	Name        string // e.g., "User"
	LowerName   string // e.g., "user"
	PackageName string // e.g., "domain"
}

func GenerateDomainRegistry() error {
	domainsPath := filepath.Join("internal", "core", "domain", "model")

	// Discover all domain files
	domains, err := discoverDomains(domainsPath)
	if err != nil {
		return fmt.Errorf("error discovering domains: %w", err)
	}

	if len(domains) == 0 {
		fmt.Println("No domains found in", domainsPath)
		return nil
	}

	// Sort domains by name for consistent output
	sort.Slice(domains, func(i, j int) bool {
		return domains[i].Name < domains[j].Name
	})

	// Generate domain registry
	registryPath := filepath.Join("internal", "core", "domain", "domain.go")
	if err := generateDomainRegistryFile(domains, registryPath); err != nil {
		return fmt.Errorf("error generating domain registry: %w", err)
	}

	fmt.Printf("Domain registry generated successfully at %s\n", registryPath)
	fmt.Printf("Registered %d domains:\n", len(domains))
	for _, domain := range domains {
		fmt.Printf("  - %s\n", domain.Name)
	}
	return nil
}

func discoverDomains(domainsPath string) ([]DomainInfo, error) {
	var domains []DomainInfo

	// Walk through domain model directory
	err := filepath.Walk(domainsPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories and non-Go files
		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Parse the Go file
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %w", path, err)
		}

		// Look for domain struct and NewXXXDomain function
		domainInfo := extractDomainInfo(node, path)
		if domainInfo != nil {
			domains = append(domains, *domainInfo)
		}

		return nil
	})

	return domains, err
}

func extractDomainInfo(node *ast.File, filePath string) *DomainInfo {
	var domainStruct *ast.TypeSpec
	var newDomainFunc *ast.FuncDecl

	// Look for domain struct and New function
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			// Look for struct type
			if structType, ok := x.Type.(*ast.StructType); ok {
				// Check if it embeds db.SomeType
				if hasDBEmbedding(structType) {
					domainStruct = x
				}
			}
		case *ast.FuncDecl:
			// Look for New*Domain function
			if x.Name != nil && strings.HasPrefix(x.Name.Name, "New") && strings.HasSuffix(x.Name.Name, "Domain") {
				newDomainFunc = x
			}
		}
		return true
	})

	// If we found both struct and New function, extract domain info
	if domainStruct != nil && newDomainFunc != nil {
		domainName := domainStruct.Name.Name
		return &DomainInfo{
			Name:        domainName,
			LowerName:   strings.ToLower(domainName),
			PackageName: "domain",
		}
	}

	return nil
}

func hasDBEmbedding(structType *ast.StructType) bool {
	for _, field := range structType.Fields.List {
		// Check for embedded field like *db.User
		if len(field.Names) == 0 { // Embedded field has no names
			if starExpr, ok := field.Type.(*ast.StarExpr); ok {
				if selExpr, ok := starExpr.X.(*ast.SelectorExpr); ok {
					if ident, ok := selExpr.X.(*ast.Ident); ok && ident.Name == "db" {
						return true
					}
				}
			}
		}
	}
	return false
}

func generateDomainRegistryFile(domains []DomainInfo, outputPath string) error {
	moduleName := utils.GetModuleName()
	f := jen.NewFile("domain_entries")

	// Add header comment
	f.Comment("Package domain_entries provides all domain for the application.")
	f.Comment("Code generated by Domain Generator. DO NOT EDIT.")
	f.Comment("Template: https://github.com/alfariiizi/vandor-cli")

	// Add imports
	f.ImportName(moduleName+"/internal/core/domain/builder", "domain_builder")
	f.ImportName(moduleName+"/internal/core/domain/model", "domain")
	f.ImportName(moduleName+"/internal/infrastructure/db", "db")
	f.ImportName("go.uber.org/fx", "fx")

	// Generate Domain struct
	domainFields := []jen.Code{}
	for _, domain := range domains {
		domainFields = append(domainFields,
			jen.Id(domain.Name).Qual("domain_builder", "Domain").Types(
				jen.Op("*").Qual("db", domain.Name),
				jen.Op("*").Qual("domain", domain.Name),
			),
		)
	}
	f.Type().Id("Domain").Struct(domainFields...)

	// Generate NewDomain constructor
	constructorBody := []jen.Code{}
	for _, domain := range domains {
		constructorBody = append(constructorBody,
			jen.Id(domain.Name).Op(":").Qual("domain", "New"+domain.Name+"Domain").Call(jen.Id("client")),
		)
	}

	f.Func().Id("NewDomain").Params(
		jen.Id("client").Op("*").Qual("db", "Client"),
	).Op("*").Id("Domain").Block(
		jen.Return(jen.Op("&").Id("Domain").Values(jen.Dict(
			func() jen.Dict {
				dict := jen.Dict{}
				for _, domain := range domains {
					dict[jen.Id(domain.Name)] = jen.Qual("domain", "New"+domain.Name+"Domain").Call(jen.Id("client"))
				}
				return dict
			}(),
		))),
	)

	// Generate fx.Module
	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit("domain"),
		jen.Qual("fx", "Provide").Call(
			jen.Id("NewDomain"),
		),
	)

	// Ensure directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save file: %w", err)
	}

	return nil
}
