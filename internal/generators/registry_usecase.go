package generators

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
)

func GenerateUsecaseRegistry() error {
	usecaseDir := "internal/core/usecase"
	
	// Discover usecases
	usecases, err := discoverUsecases(usecaseDir)
	if err != nil {
		return fmt.Errorf("error discovering usecases: %w", err)
	}

	if len(usecases) == 0 {
		fmt.Println("No usecases found in", usecaseDir)
		return nil
	}

	// Sort for consistent output
	sort.Strings(usecases)

	// Generate usecases.go
	registryPath := filepath.Join(usecaseDir, "usecases.go")
	if err := generateUsecaseRegistryFile(usecases, registryPath); err != nil {
		return fmt.Errorf("error generating usecase registry: %w", err)
	}

	fmt.Printf("Usecase registry generated successfully at %s\n", registryPath)
	fmt.Printf("Registered %d usecases:\n", len(usecases))
	for _, usecase := range usecases {
		fmt.Printf("  - %s\n", usecase)
	}
	return nil
}

func discoverUsecases(usecaseDir string) ([]string, error) {
	files, err := os.ReadDir(usecaseDir)
	if err != nil {
		return nil, err
	}

	var usecases []string

	for _, file := range files {
		if file.IsDir() || file.Name() == "usecases.go" || !strings.HasSuffix(file.Name(), ".go") {
			continue
		}

		path := filepath.Join(usecaseDir, file.Name())
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", path, err)
		}

		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				typeSpec := spec.(*ast.TypeSpec)
				if !typeSpec.Name.IsExported() {
					continue
				}
				// Filter only aliases to model.Usecase[...] (not structs like LoginInput)
				switch typeSpec.Type.(type) {
				case *ast.IndexExpr, *ast.IndexListExpr:
					usecases = append(usecases, typeSpec.Name.Name)
				}
			}
		}
	}

	return usecases, nil
}

func generateUsecaseRegistryFile(usecases []string, outputPath string) error {
	f := jen.NewFile("usecase")

	// Add header comment
	f.Comment("Package usecase provide usecases for the application.")
	f.Comment("Code generated by Usecase Generator. DO NOT EDIT.")
	f.Comment("Template: https://github.com/alfariiizi/vandor-cli.")

	// Add imports
	f.ImportName("go.uber.org/fx", "fx")

	// Generate Usecases struct
	usecaseFields := []jen.Code{}
	for _, usecase := range usecases {
		usecaseFields = append(usecaseFields, jen.Id(usecase).Id(usecase))
	}
	f.Type().Id("Usecases").Struct(usecaseFields...)

	// Generate constructor parameters
	constructorParams := []jen.Code{}
	constructorDict := jen.Dict{}
	
	for _, usecase := range usecases {
		param := strings.ToLower(usecase[:1]) + usecase[1:]
		constructorParams = append(constructorParams, jen.Id(param).Id(usecase))
		constructorDict[jen.Id(usecase)] = jen.Id(param)
	}

	// Generate NewUsecases constructor
	f.Func().Id("NewUsecases").Params(constructorParams...).Op("*").Id("Usecases").Block(
		jen.Return(jen.Op("&").Id("Usecases").Values(constructorDict)),
	)

	// Generate fx.Module with providers
	moduleProviders := []jen.Code{}
	for _, usecase := range usecases {
		moduleProviders = append(moduleProviders, jen.Id("New"+usecase))
	}
	moduleProviders = append(moduleProviders, jen.Id("NewUsecases"))

	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit("usecase"),
		jen.Qual("fx", "Provide").Call(moduleProviders...),
	)

	// Ensure directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save file: %w", err)
	}

	return nil
}