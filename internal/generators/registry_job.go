package generators

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/alfariiizi/vandor-cli/internal/utils"
)

type JobInfo struct {
	ModuleName string // Module name e.g. vandor
	BaseName   string // SendEmail
	Name       string // Struct name e.g. SendEmail
	VarName    string // var name e.g. sendEmail
	TaskName   string // e.g. send_email
	Payload    string // Payload struct name
}

func GenerateJobRegistry() error {
	jobsDir := "internal/delivery/worker/job"

	// Discover all jobs
	jobs, err := discoverJobs(jobsDir)
	if err != nil {
		return fmt.Errorf("error discovering jobs: %w", err)
	}

	if len(jobs) == 0 {
		fmt.Println("No jobs found in", jobsDir)
		return nil
	}

	// Sort jobs by name for consistent output
	sort.Slice(jobs, func(i, j int) bool {
		return jobs[i].Name < jobs[j].Name
	})

	// Generate jobs.go
	jobsPath := filepath.Join("internal", "core", "job", "jobs.go")
	if err := generateJobsFile(jobs, jobsPath); err != nil {
		return fmt.Errorf("error generating jobs file: %w", err)
	}

	// Generate worker_gen.go
	workerPath := filepath.Join("internal", "delivery", "worker", "worker_gen.go")
	if err := generateWorkerFile(jobs, workerPath); err != nil {
		return fmt.Errorf("error generating worker file: %w", err)
	}

	fmt.Printf("Job registry generated successfully\n")
	fmt.Printf("  - jobs.go: %s\n", jobsPath)
	fmt.Printf("  - worker_gen.go: %s\n", workerPath)
	fmt.Printf("Registered %d jobs:\n", len(jobs))
	for _, job := range jobs {
		fmt.Printf("  - %s\n", job.Name)
	}

	return nil
}

func discoverJobs(jobsDir string) ([]JobInfo, error) {
	var jobs []JobInfo

	err := filepath.Walk(jobsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(path, ".go") && !info.IsDir() {
			job := parseJobFile(path)
			if job.Name != "" {
				jobs = append(jobs, job)
			}
		}
		return nil
	})

	return jobs, err
}

func parseJobFile(path string) JobInfo {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
	if err != nil {
		return JobInfo{}
	}

	jobName := filepath.Base(path)
	jobName = strings.TrimSuffix(jobName, ".go")

	// Convert filename to PascalCase (e.g., send_email -> SendEmail)
	parts := strings.Split(jobName, "_")
	for i, part := range parts {
		parts[i] = utils.ToPascalCase(part)
	}
	baseName := strings.Join(parts, "")

	job := JobInfo{
		ModuleName: utils.GetModuleName(),
		BaseName:   baseName,
		Name:       baseName,
		VarName:    strings.ToLower(baseName[:1]) + baseName[1:],
		TaskName:   toTaskName(jobName),
		Payload:    baseName + "Payload",
	}

	// Verify this file actually contains a job by looking for type declarations
	for _, decl := range node.Decls {
		if g, ok := decl.(*ast.GenDecl); ok && g.Tok == token.TYPE {
			for _, spec := range g.Specs {
				ts := spec.(*ast.TypeSpec)
				if ts.Name.IsExported() && !strings.HasPrefix(ts.Name.Name, "New") {
					// Found a valid job type, return the job info
					return job
				}
			}
		}
	}

	// No valid job found in this file
	return JobInfo{}
}

func toTaskName(varName string) string {
	// Convert camelCase to snake_case for task names
	var result strings.Builder
	for i, r := range varName {
		if i > 0 && 'A' <= r && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func generateJobsFile(jobs []JobInfo, outputPath string) error {
	f := jen.NewFile("job")

	// Add header comment
	f.Comment("Code generated by vandor; DO NOT EDIT.")

	// Add imports
	f.ImportName("go.uber.org/fx", "fx")

	// Generate Jobs struct
	jobFields := []jen.Code{}
	for _, job := range jobs {
		jobFields = append(jobFields, jen.Id(job.BaseName).Id(job.BaseName))
	}
	f.Type().Id("Jobs").Struct(jobFields...)

	// Generate constructor parameters
	constructorParams := []jen.Code{}
	constructorDict := jen.Dict{}

	for _, job := range jobs {
		constructorParams = append(constructorParams, jen.Id(job.BaseName).Id(job.BaseName))
		constructorDict[jen.Id(job.BaseName)] = jen.Id(job.BaseName)
	}

	// Generate NewJobs constructor
	f.Func().Id("NewJobs").Params(constructorParams...).Op("*").Id("Jobs").Block(
		jen.Return(jen.Op("&").Id("Jobs").Values(constructorDict)),
	)

	// Generate fx.Module with providers
	moduleProviders := []jen.Code{}
	for _, job := range jobs {
		moduleProviders = append(moduleProviders, jen.Id("New"+job.BaseName))
	}
	moduleProviders = append(moduleProviders, jen.Id("NewJobs"))

	f.Var().Id("Module").Op("=").Qual("fx", "Module").Call(
		jen.Lit("job"),
		jen.Qual("fx", "Provide").Call(moduleProviders...),
	)

	// Ensure directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save jobs file: %w", err)
	}

	return nil
}

func generateWorkerFile(jobs []JobInfo, outputPath string) error {
	f := jen.NewFile("worker")

	// Add header comment
	f.Comment("Code generated by vandor; DO NOT EDIT.")

	if len(jobs) == 0 {
		// Generate empty file
		f.Comment("No jobs found")
	} else {
		moduleName := utils.GetModuleName()

		// Add imports
		f.ImportName("context", "context")
		f.ImportName("encoding/json", "json")
		f.ImportName("log", "log")
		f.ImportName(moduleName+"/internal/core/job", "job")
		f.ImportName("github.com/hibiken/asynq", "asynq")

		// Generate RegisterJobs function
		f.Func().Id("RegisterJobs").Params(
			jen.Id("mux").Op("*").Qual("asynq", "ServeMux"),
			jen.Id("jobs").Op("*").Qual("job", "Jobs"),
		).Block(generateJobRegistrations(jobs)...)
	}

	// Ensure directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := f.Save(outputPath); err != nil {
		return fmt.Errorf("failed to save worker file: %w", err)
	}

	return nil
}

func generateJobRegistrations(jobs []JobInfo) []jen.Code {
	var statements []jen.Code

	for _, job := range jobs {
		// Generate handler function for each job
		handlerFunc := jen.Func().Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("t").Op("*").Qual("asynq", "Task"),
		).Error().Block(
			jen.Var().Id("payload").Qual("job", job.Payload),
			jen.If(jen.Id("err").Op(":=").Qual("json", "Unmarshal").Call(jen.Id("t").Dot("Payload").Call(), jen.Op("&").Id("payload")), jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Id("err")),
			),
			jen.Return(jen.Id("jobs").Dot(job.BaseName).Dot("Handle").Call(jen.Id("ctx"), jen.Id("payload"))),
		)

		// Register the handler
		statements = append(statements,
			jen.Id("mux").Dot("HandleFunc").Call(
				jen.Id("jobs").Dot(job.BaseName).Dot("Key").Call(),
				handlerFunc,
			),
		)
	}

	return statements
}
